// Generated by CoffeeScript 1.8.0
var exec, forever, fs, mixin, path, semver, token;

forever = require('forever-monitor');

fs = require('fs');

path = require('path');

semver = require('semver');

exec = require('child_process').exec;

mixin = require('flatiron').common.mixin;

token = require('../middlewares/token');

module.exports.start = function(app, callback) {
  var env, foreverOptions, pwd, result, _ref;
  result = {};
  if (this.process) {
    this.process.stop();
  }
  if ((_ref = app.name) === "home" || _ref === "proxy" || _ref === "data-system") {
    pwd = token.get();
  } else {
    pwd = app.password;
  }
  env = {
    NAME: app.name,
    TOKEN: pwd,
    USER: app.user,
    USERNAME: app.user,
    SUDO_USER: app.user,
    HOME: app.userDir
  };
  foreverOptions = {
    fork: true,
    silent: true,
    max: 5,
    stdio: ['ipc', 'pipe', 'pipe'],
    cwd: app.dir,
    logFile: app.logFile,
    outFile: app.logFile,
    errFile: app.errFile,
    env: env,
    killTree: true,
    killTTL: 0,
    command: 'node'
  };
  if (fs.existsSync(app.logFile)) {
    app.backup = app.logFile + "-backup";
    if (fs.existsSync(app.backup)) {
      fs.unlink(app.backup);
    }
    fs.rename(app.logFile, app.backup);
  }
  fs.openSync(app.logFile, 'w');
  if (fs.existsSync(app.errFile)) {
    app.errBackup = app.errFile + "-backup";
    if (fs.existsSync(app.errBackup)) {
      fs.unlink(app.errBackup);
    }
    fs.rename(app.errFile, app.errBackup);
  }
  fs.openSync(app.errFile, 'w');
  foreverOptions.options = ['--plugin', 'net', '--plugin', 'setuid', '--setuid', app.user];
  return fs.readFile("" + app.dir + "/package.json", (function(_this) {
    return function(err, data) {
      var carapaceBin, onError, onExit, onPort, onRestart, onStart, onTimeout, process, responded, start, timeout, _ref1;
      data = JSON.parse(data);
      if (((_ref1 = data.scripts) != null ? _ref1.start : void 0) != null) {
        start = data.scripts.start.split(' ');
        app.startScript = path.join(app.dir, start[1]);
        if (start[0] === "coffee") {
          foreverOptions.options = foreverOptions.options.concat(['--plugin', 'coffee']);
        }
      }
      if ((start == null) && (app.server.slice(server.lastIndexOf("."), app.server.length) === ".coffee")) {
        foreverOptions.options = foreverOptions.options.concat(['--plugin', 'coffee']);
      }
      fs.stat(app.startScript, function(err, stats) {
        if (err != null) {
          err = new Error("package.json error: can\'t find starting script: " + app.startScript);
          return callback(err);
        }
      });
      foreverOptions.options.push(app.startScript);
      carapaceBin = path.join(require.resolve('cozy-controller-carapace'), '..', '..', 'bin', 'carapace');
      process = new forever.Monitor(carapaceBin, foreverOptions);
      responded = false;
      onExit = function() {
        process.removeListener('error', onError);
        clearTimeout(timeout);
        console.log('callback on Exit');
        if (callback) {
          return callback(new Error("" + app.name + " CANT START"));
        } else {
          console.log("" + app.name + " HAS FAILLED TOO MUCH");
          return setTimeout((function() {
            return process.exit(1);
          }), 1);
        }
      };
      onError = function(err) {
        if (!responded) {
          err = err.toString();
          responded = true;
          callback(err);
          process.removeListener('exit', onExit);
          process.removeListener('message', onPort);
          return clearTimeout(timeout);
        }
      };
      onStart = function(monitor, data) {
        return result = {
          monitor: process,
          process: monitor.child,
          data: data,
          pid: monitor.childData.pid,
          pkg: app
        };
      };
      onRestart = function() {
        return console.log("" + app.name + ":restart");
      };
      onTimeout = function() {
        process.removeListener('exit', onExit);
        process.stop();
        err = new Error('Error spawning drone');
        err.stdout = stdout.join('\n');
        err.stderr = stderr.join('\n');
        console.log('callback timeout');
        return callback(err);
      };
      onPort = function(info) {
        if (!responded && (info != null ? info.event : void 0) === 'port') {
          responded = true;
          result.port = info.data.port;
          callback(null, result);
          process.removeListener('exit', onExit);
          process.removeListener('error', onError);
          process.removeListener('message', onPort);
          return clearTimeout(timeout);
        }
      };
      process.start();
      timeout = setTimeout(onTimeout, 8000000);
      process.once('exit', onExit);
      process.once('error', onError);
      process.once('start', onStart);
      process.on('restart', onRestart);
      return process.on('message', onPort);
    };
  })(this));
};
